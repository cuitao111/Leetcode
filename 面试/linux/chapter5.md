## 阻塞/非阻塞、同步/异步（网络IO）
典型的一次IO两个阶段？数据就绪和数据读写

            阻塞    调用IO方法（recv、read）的线程进入阻塞状态
数据就绪
            非阻塞  不会改变线程状态，通过返回值判断
操作系统    TCP接受缓冲区

ssize_t recv(int sockfd, void *buf, size_t len, int flags);

int size = recv(sockfd, buf, 1024, 0);
    返回值
        -1：出错  (EINTR(信号)，EAGAIN/EWOULDBLOCK(读不到数据))
        0：读取到数据末尾， 对方关闭连接
        >0:读到了多少数据


            同步：自己从内核区接收数据
数据读写
            异步：操作系统帮忙搬运数据
                    sockfd buf 通知方式 sigio信号
应用程序


在处理IO的时候，阻塞和非阻塞都是同步IO,只有使用了特殊的API才是异步IO。
aio_read()
aio_write()

一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。

select poll epoll（IO多路复用）是同步的

## Unix/Linux的五种IO模型
a. 阻塞
b. 非阻塞
c. IO复用
d. 信号驱动 不需要轮询判断
e. 异步


## Web Server(网页服务器)
一个服务器软件（程序）或者运行这个服务器软件的硬件（计算机）
主要功能是通过HTTP协议与客户端（Browser）进行通信，来接受，存储来自客户端的HTTP请求，并对其请求做出HTTP响应，返回客户端其请求的内容（文件、网页等）或返回一个Error信息。

HTTP协议（应用层）
基于请求-响应模式

## 服务器编程的基本框架
基本框架都一样，不同之处在于逻辑处理

IO处理单元 请求队列 逻辑单元

### 两种高效的事件处理模式
服务器需要处理的三类事件：I/O 事件、信号及定时事件。有两种高效的处理模式：Reactor和Proactor

### Reactor模式
要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的化就立即将该事件通知工作线程

### Proactor模式
使用异步模型，将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。

### 线程池
空间换时间，浪费服务器的硬件资源，换取运行效率。
池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。
当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中
获取，无需动态分配。
当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。 

## 压力测试
webbench


## 重点 
高并发处理需要使用多进程或者多线程
IO多路复用只是单线程下能够检测多个事件发生

## 需要巩固
线程 锁 条件变量 信号量


pthread_create(m_threads + i, NULL, worker, this) != 0) 线程何时调用worker
