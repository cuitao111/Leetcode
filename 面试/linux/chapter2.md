
### 2.1 进程概述

### 程序和进程
程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：
二进制格式标识：
机器语言指令：
程序入口地址：
数据：
符号及重定位表：程序中函数和变量的位置及名称。调试和运行时符号解析。
共享库动态链接信息：
其他信息：描述如何创建进程

进程是正在运行的程序的实例。程序不占用内存，cpu资源。是一个具有一定独立功能的程序关于某个数据几何的一次运行活动。资源分配的基本单元。
内核角度看，用户空间和内科空间

### 单道、多道程序设计
单道：计算机内存中只允许一个程序运行。
多道：


### 时间片
又称为量子或者处理器片
通常5ms和800ms

时间片由操作系统内核调度程序分配给每个进程。
当所有进程都处于时间片耗尽的状态，内核会重新为每个进程分配时间片。

### 并行和并发

并行：同一时刻，有多条指令在多个CPU上同时执行
并发：同一时刻只有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上有有多个进程同时执行的效果

### 进程控制块PCB

task_struct结构体
/usr/src/linux-headers-5.8.0-36-generic/include/linux/sched.h 
进程id：进程有唯一的id，用pid_t类型表示，其实就是一个非负整数
进程的状态：创建、就绪、运行、阻塞（挂起）、结束（停止）
进程切换时需要保存和恢复一些CPU寄存器
描述虚拟地址空间信息
描述控制终端的信息
当前工作目录（Current Working Directory）
umask掩码
文件描述符表，包含很多指向file结构体的指针
和信号相关的信息
用户id和组id
会话和进程组
进程可以使用的资源上限

### 进程间的状态转换

创建，就绪，运行，阻塞，终止
就绪太：进行已分配到除了cpu之外的所有必要资源后，只要再获得cpu，可以立即执行
阻塞太：指进程不具备运行条件，正在等待某个事件完成

ps aux/ajx 快照，非动态显示
a:显示终端上所有的进程，包括其他用户的进程
u:显示进程详细信息
x:显示没有控制终端的进程
j:列出与作业控制相关的信息

PID 进程ID
PPID 父进程ID
PGID 进程组ID
SID 会话ID

TTY 所属于的终端
STAT：
D 不可中断 R正在运行或在队列中的进程
S大写 处于休眠 T停止
Z 僵尸进程 W 进入内存交换
X 死掉的进程    <高优先级
N 低优先级 s包含子进程
+ 位于前台的进程组

top
-d 指定更新的事件
M 按内存使用量
P 按CPU使用率
T 根据进程运行时间长短
U 根据用户名
K 输入指定的PID杀死进程

kill -l 列出所有信号
killall name 根据进程名杀死

### 进程号和相关函数
进程号唯一但可以重用，进程号类型为pid_t 进程号范围0~32767
除init进程其他进程都是由另一个进程创建，PPID
终端是执行进程的父进程
进程组是一个或多个进程的几何。他们之间相互关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号(PGID)。默认情况下，当前的进程号会当作当前的进程组号。

相关函数
pid_t gepid(void);
pid_t geppid(void);
pid_t gepgid(pid_t pid);

### 进程创建

fork() exev函数族

### 父子进程虚拟地址空间情况
执行到 pid_t pid = fork(); 时
复制一份虚拟地址空间 只有pid和栈中fork()返回值pid不同
写时拷贝 读时共享
不复制整个进程的地址空间，让父子共享一个，(父子有两处不同↑)
资源的复制是在需要写入时才会进行

### GDB多进程调试
调试父进程或者子进程：set follow-fork-mode [parent(默认) | child]

设置调试模式：set detach-on-fork [on | off]
设置off 当调试当前进程时，其他进程会被GDB挂起

查看调试的进程： info inferiors
更改进程：inferior n
使进程脱离GDB调试：detach inferiors id

### exec 函数族
一系列功能相同或相似的函数
作用：根据指定文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。

exec函数族的函数执行成功后不会返回，因为已经被替换
l(list)         参数地址列表，以空指针结尾
v(vector)       存有各参数地址的指针数组地址
p(path)         按PATH环境变量指定的目录搜索可执行文件
e(environment)  存有环境变量字符串地址的指针数组地址


### 进程控制 孤儿进程 僵尸进程


### 进程退出

#include <stdlib.h>
void exit(int status); //标准C库 调用退出处理函数 刷新I/O

#include <unistd.h>
void _exit(int status);

### 孤儿进程
父进程结束结束，但子进程还在运行(未运行结束)
每当出现一个孤儿进程的时候，内核就把孤儿进程设置父进程为init()
而init()进程会循环地wait()它已经退出的子进程。这样， 当一个孤儿进程结束了生命周期，init进程处理它的一切善后哦工作。
孤儿进程没有什么危害

### 僵尸进程
每个进程结束之后，都会释放自己地址空间中用户区数据，内核区的PCB没有办法释放掉，需要父进程去释放。
进程终止时，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程。
不能被kill -9 杀死
如果父进程不用wait() waitpid() 保留的信息不会释放，其进程号被一直占用，但系统所能使用的进程号有限。大量僵尸进程有危害。

进程退出时，内核释放该进程所有的资源，包括打开的文件、占用的内存等。但是为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。

wait waitpid 阻塞
waitpid可以设置不阻塞 还可以指定哪个子进程结束
一次wait或waitpid调用只能清理一个子进程，清理多个使用循环

### 退出信息相关宏函数


## 进程间通信

### 进程间通讯概念

进程是一个独立的资源分配单元，不同进程（通常指用户进程）的资源是独立的，没有关联，不能再一个进程中直接访问另一个进程的资源。
但是，进程不是孤立的，不同的进程需要进行信息交互和状态的传递等，因此需要IPC（Inter Processes Communication）

目的：
数据传输：一个进程需要将它的数据发送给另一个进程
通知事件：一个进程需要向另一个或异俗发送笑死，通知他们发生了事件
资源共享：多个进程之间共享资源。为了做到这一点，需要内核提供互斥和同步机制。
进程控制：有些进程希望完全控制另一个进程的执行（GDB），此进程希望能够拦截另一个进程的所有陷入和异常，并能够及时直到它的状态改变

### 进程间通信方式

同一主机间通信
    Unix进程间通信方式
        匿名管道
        有名管道
        信号
    System V进程间通信方式
    POSIX进程通信方式
        消息队列
        共享内存/内存映射
        信号量
不同主机（网络）进程间通信
    Socket

### 匿名管道
是UNIX系统IPC的最古老形式，所有UNIX系统都支持这种通信机制
统计一个目录中问及啊你的数目命令: ls | wc -l,为了执行该命令，
shell创建了两个进程分别执行ls和wc

ls   stdout  ->         字节流，单向     -> stdin       wc
    (fd  1)     管道写入端     管道读取段   （fd 0）

### 管道特点
管道其实是一个在内核内存中维护的缓冲区，这个缓冲器的存储能力是有限的，不同操作系统的大小不一定相同。
管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。
一个管道是一个字节流，使用管道不存在消息和消息边界的概念，从管道读取的进程可以是任意大小的数据块，而不管写入管道的数据块大小是多少
通过管道传递的数据是顺序的，从管道读取出来的字节的顺序和他们被写入管道的顺序是一样的。
管道中数据传递的方式是单向的，一端写，一端读，半双工。
（遥控器-》电视 单工 ； 打电话 双工）
管道读取数据是一次性操作，一旦独奏，就从管道中抛弃释放空间以便吸入更多数据，无法用lseek来随机访问数据。
匿名管道只能在具有公共祖先的进程（父进程与子进程， 或两个兄弟进程，具有亲缘关系）之间使用

为什么只能在有关系的进程间通信
父进程和子进程共享文件描述符表，将读操作对应管道头部

管道的数据结构
循环队列

使用：
#include
int pipe(int  pipefd[2]); //创建
ulimit -a
fpathconf

### 管道的读写特点和管道设置为非阻塞

特点:
假设都是阻塞I/O操作
1.所有的指向管道写端的文件描述符都关闭了(管道写端的引用计数为0),
有进程从管道的读端读数据,那么管道中剩余的数据都被读取以后,再次read会返回0,就像督导文件末尾一样
2.如果有指向管道写端的文件描述符没有关闭(管道的写端引用计数大于0), 而持有管道写端的进程没有写,有进程从管道读取数据,没有数据就会阻塞,直到有数据才读到数据才会读数据返回.
3.所有读端的引用计数为0,有进程向管道写数据.该进程收到SIGPIC,通常导致进程终止.

4.如果有指向管道读端的文件描述符没有关闭,(读端计数大于0),而持有管道读端的进程没有读数据,在管道被写满时再次write会阻塞,直到有空位置.

总结:
    读:管道中有数据,read返回实际督导的字节数
    无数据:写端全部关闭,read返回0(相当于读到文件末尾)
        写端没有完全关闭, read阻塞
    写管道:
        读端全关闭,进程异常终止(SIGPIPE)
        没有全关闭:
            管道满了, write阻塞
            管道没满, wite将数据写入,返回写入的字节数


### 有名管道
匿名管道：先建pipe在fork

有名管道：FIFO 不同于匿名管道之处在于它提供了一个路径名与之关联，以FIFO文件形式存在于文件系统，打开方式与普通文件一样，只要两个进程都能访问该文件路径，就能通过FIFO相互通信。
一旦打开FIFO，就能用I/0系统调用。read write close 先入先出
有3个文件访问FIFO？

有名无名有一些特点相同，不一样地方在于：
1.FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放于内存中。
2.当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中，以便后续使用。
3.FIFO有名字，不相关进程可以通信。靠有名管道文件联系。
虽然FIFO是有名实体，但都是在内核的缓冲区操作，文件实体中不存放信息

### 使用
命令：mkfifo 名字
函数：
FIFO严格遵循先进先出，不支持lseek文件定位操作

### 实现聊天功能
思路
两个管道 A->B B->A
A：
1.以只写的方式打开管道1
2.以只读的方式打开管道2
3.循环写读数据
while(1){
    键盘 fgets
    写管道1

    读管道2
}

B：相反 不能同时写，同时读

### 内存映射
将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件

### 注意事项
1.如果对mmap返回值ptr 做ptr++ , munmap是否能成功
void * ptr = mmap(...);
可以++但是不建议
释放时 需要释放ptr 而不是ptr++的位置

2.如果oepn时O_RDONLY, mmap时prot参数读写 会失败返回MAP_FALED

3.如果文件偏移量为1000
必须为4K的整数倍，返回MAP_FAILED

4.mmap调用失败
    - 第二个参数 length = 0
    - 第三个参数：port
      - 只制定了写权限
      - prot PROT_READ|PROT_WRITE
        - 第5个fd通过open函数时指定的 O_RDONLY/O_WRONLY
5.可以open时O_CREAT一个新文件来创建映射区码？
    - 可以但大小不能为0
    - 可以对新的文件进行扩展
      - lseek()
      - truncate()
6.mmap后关闭文件描述符，对mmap映射有没有影响
    int fd = open("XXX");
    mmap(...,fd,...)
    close(fd);
    mmap时相当于拷贝，创建映射区的fd被关闭，没有任何影响。

7.对ptr越界操作会怎么样？
void * ptr = mmap(NULL, 100, ,,,,)
4K
越界操作非法内存->段错误


### 信号
进程间通信的最古老方式之一，事件发生时对进程的通知方式，也称为软件中断。他是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。
引发内核为进程产生信号（软件中断）的各类事件：
1.前台进程，用户输入特殊字符 Ctrl + C
2.硬件异常，如被0除或者引用了无法访问的内存区域
3.系统状态变化， 比如alarm定时器引起SIGALRM信号，进程执行CPU时间超时，或者该进程的某个子进程退出。
4.运行kill命令或Kill函数。

目的：让进程知道发生了一个特定的事情。
强迫进程执行它自己代码中的信号处理程序。

特点：
简单（使用起来），不能携带大量信息
满足某个特定的条件才发送，优先级比较高

查看系统定义的信号列表：kill -l
前31个为常规信号，其余为实时信号

SIGUP SIGINT(^C)  SIGQUIT(^\)
SIGKILL(-9) SIGSEGV(段) SIGPIPE(管道) SIGCHLD(子进程) SIGCONT(继续) SIGSTOP(暂停)

man 7 signal

信号的5种默认处理动作
Term    终止进程
Ign     当前进程忽略掉
Core    终止进程，并生成一个Core（核心转储）文件 为了对错误进行调试
Stop    暂停当前进程
Cont    继续执行当前被暂停的进程

信号的几种状态：**产生、未决、递达**
SIGKILL 和SIGSTOP信号不能被捕捉，阻塞或者忽略，只能执行默认动作。

kill raise abort alarm setitimer


### 信号集
有很多系统调用需要一组不同的信号，可以用信号集的数据结构表示sigset_t
位图机制
阻塞信号集
未决信号集（只能读不能修改）
未决：一种状态 阻塞：一个开关动作，阻止信号被处理，而不是阻止信号产生。
1.用户通过键盘 ^C,产生SIGINT信号（被创建）
2.信号产生但没有被处理（未决）
    - 在内核种将所有的没有被处理的信号存储在未决信号集
    - SIGINT存储在第2位标志位
        - 标志位1说明信号未决 为0 不是未决
3.这个未决状态信号，需要处理，处理前需要和阻塞信号集比较
    - 阻塞信号集默认不阻塞任何信号
    - 如果想要阻塞某些信号需要用户调用系统API
4.处理时和阻塞信号集种的标志位进行查询，看是不是对信号设置阻塞
    - 没阻塞，处理 阻塞了，继续处于未决态，直到解除，这个信号被处理

### 内核实现信号捕捉的过程
1、在执行主控流程的某条指令时因为**中断、异常或系统调用**进入内核
2、内核处理完异常准备回用户模式之前先处理当前进程中可以递送的信号
3、如果信号的处理动作为自定义的信号处理函数，则回到用户模式执行信号处理函数（回调）
4、信号处理函数返回时执行特殊的系统调用sigreturn再次进入内核
5、返回用户模式从主控制流程中上次被中断的地方继续向下执行

内核中有个阻塞信号集，在信号捕捉过程中会使用临时的阻塞信号集，信号处理完恢复到原来
执行某个回调函数期间，该位置信号会被默认屏蔽掉,当前一个处理完之后才会处理后一个，
阻塞的常规信号不支持排队

### SIGCHLD信号
产生条件
    子进程终止
    子进程接受到SIGSTOP
    子进程处在停止太，接收到SIGCONT后唤醒
以上三种条件都会给父进程发送SIGCHLD信号，父进程默认忽略该信号

处理僵尸进程：回调SIGCHLD信号时执行 wait

### 共享内存
共享内存的效率比内存映射高 ，因为需要文件
允许多个进程共享物理内存的同一块区域

shmget() shmat() shmdt() shmctl()
#include <sys/ipc.h>
#include <sys/shm.h>
int shmget(Key_t key, size_t size, int shmflg);
    - 功能：创建一个新的共享内存段，获取一个既有的共享内存段标识
      - 新创建的内存段 中数据都初始化为0
    - 参数
      - key:key_t是一个整形，通过这个找到或者创建一个共享内存
        - 一般16进制非0值
      - size：共享内存大小
      - shmflg:属性
        - 访问权限
        - 附加属性：创建/判断共享内存是不是存在
            - 创建：IPC_CREAT
            - 判断共享内存是否存在：IPC_EXCL需要和IPC_CREAT一起使用 IPC_CREAT|IPC_EXCL|0664
    - 返回值：
      - 成功：>0 共享内存引用的ID 失败：-1 + 错误号

#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
    - 功能：和当前的进程进行关联
    - 参数：
      - shmid：共享内存标识， 由shmget返回值获取
      - shmaddr：申请的共享内存的起始地址，指定NULL，内核指定
      - shmflg：对共享内存的操作
        - SHM_EXEC:可执行
        - SHM_RDONLY:只读,必须要有读权限
        - 0：读写
    - 返回值：
      - 成功：共享内存的首地址， 失败：(void *)-1 错误号

#include <sys/types.h>
#include <sys/shm.h>
void *shmat(int shmid, const void *shmaddr, int shmflg);
    - 功能：解除关联
    - 参数：
      - shmaddr：申请的共享内存的起始地址
    - 返回值：成功0 失败：-1

#include <sys/ipc.h>
#include <sys/shm.h>
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
    - 功能：删除共享内存，共享内存要删除才会消逝，创建共享内存的进程被销毁对共享内存没有影响
    - 参数:
      - shmid:共享内存的id
      - cmd:要进行的操作
          - IPC_STAT:获取共享内存当前的状态
          - IPC_SET:设置状态
          - IPC_RMID:标记共享内存需要被销毁
      - buf:需要设置或者获取的共享内存属性信息
          - IPC_STAT:buf存储
          - IPC_SET：buf中需要初始化数据，设置到内核中
          - IPC_RMID:没有用，NULL

#include <sys/types.h>
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj_id);
    - 功能： 根据指定的路径名，和int值，生成一个共享内存的key
          - 如果两个参数是一致的，返回值也一致，由此实现进程通信
    - 参数：
        - pathname:指定一个存在的路径
            /home/userfile/cuitao/a.txt
            /            /root
        - proj_id: int ,但是这个系统调用指挥使用其中的4个位
              - 范围 0 - 255(2^8) 一般指定一个字符
  
1.操作系统如何直到一块共享内存被多少进程关联？
共享内存维护了一个结构体struct shmid_ds.shm_nattch (shmctl文档中)

ipcs -a  -m(共享内存) -q(队列) -s(信号)
ipcrm -M key   -m id

2.可不可以对共享内存进行多次删除 shmctl
    —— 可以 因为shmctl只是标记删除，当和共享内存关联进程为0，真正删除
    取消关联之后不能操作，也不能再次关联

3.共享内存和内存映射
    1)共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）
    2)共享内存效率更高
    3)所有进程操作的同一内存/每个进程在自己的虚拟地址空间有独立内存
    4)数据安全：
        进程突然退出 共享内存还存在，内存映射消失（在进程里）
        电脑死机: 共享无 映射无，但由于磁盘文件还在，内存映射区对应文件存在
    5)生命周期
        内存映射：进程退出， 销毁
        共享：进程退出，还在；当标记删除且关联的进程为0才销毁
            进程退出，自动和共享内存取消关联
什么时候标记删除？ shmctl 取消关联

### 守护进程init
终端:用户通过终端登录系统后得到一个shell进程，终端作为控制这个进程的控制终端
进程组 ：会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合。由一个或多个共享同一进程组标识符(PGID)进程组成。方便管理
新进程会继承其父进程所属进程组的ID
生命周期：首进程创建组时刻，至最后一个成员进程退出组的时刻。
会话：会话是一组相关进程组的集合。会话首进程，
一个会话的所有进程共享单个控制终端，一个终端最多可能成为一个会话的控制终端。

pid_t getgrp(void);
pid_t getpgid(pid_t pid);
int setpgid(pid_t pid, pid_t pgid);
pid_t getsid(pid_t pid);
pid_t setdis(void);

### 守护进程
后台服务进程， 生存周期较长，独立于控制终端并周期性的执行某些任务或处理某些发生的事件，一般用d结尾的名字。
特征：
生命周期：系统启动到系统关闭。
不拥有控制终端，确保了内核永远不会为守护进程自动地生成任何控制信号以及终端相关的信号。（SIGINT、SIGQUIT）
inetd, httpd

创建步骤：
执行一个fork(),父进程退出，子进程继续执行。
子进程调用setsid()开启一个新会话。脱离控制终端
清除进程的umask以确保当守护进程创建文件和目录时拥有所需的权限。
修改进程当前的工作目录，通常会改为根目录
关闭守护进程从其父进程继承而来的所有打开这段文件描述符。（关闭标准输入输出）
关闭0、1、2之后，守护进程通常会打开/dev/null并使用dup2()使所有描述符指向这个设备。
核心业务逻辑

### 查看闪退日志
cd /var/log/

cat apport.log

VNC mobaxterm


### 查漏补缺
dup2 重定向 STDOUT_FILENO
execlp("可执行文件", "名字", 参数列表)

进程阻塞和挂起的区别

core使用步骤：
ulimit -a 查看core文件
1.ulimit -c ulimited
2.gcc prodcust.c -o prodcust -g -pthread
3../prodcust
4.gdb prodcust
5.core-file core


27节段错误 野指针

匿名内存映射 父子？

守护进程的创建过程

## 重点
进程状态的转换 创建 就绪 。。
fork()
父子进程的虚拟地址空间 读时共享 
exec
进程间通信的方式 原理
定时器，信号捕捉
守护进程
进程调度的方式
消息队列
















# Linux多进程开发