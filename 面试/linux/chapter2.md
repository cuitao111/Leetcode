
### 2.1 进程概述

### 程序和进程
程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：
二进制格式标识：
机器语言指令：
程序入口地址：
数据：
符号及重定位表：程序中函数和变量的位置及名称。调试和运行时符号解析。
共享库动态链接信息：
其他信息：描述如何创建进程

进程是正在运行的程序的实例。程序不占用内存，cpu资源。是一个具有一定独立功能的程序关于某个数据几何的一次运行活动。资源分配的基本单元。
内核角度看，用户空间和内科空间

### 单道、多道程序设计
单道：计算机内存中只允许一个程序运行。
多道：


### 时间片
又称为量子或者处理器片
通常5ms和800ms

时间片由操作系统内核调度程序分配给每个进程。
当所有进程都处于时间片耗尽的状态，内核会重新为每个进程分配时间片。

### 并行和并发

并行：同一时刻，有多条指令在多个CPU上同时执行
并发：同一时刻只有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上有有多个进程同时执行的效果

### 进程控制块PCB

task_struct结构体
/usr/src/linux-headers-5.8.0-36-generic/include/linux/sched.h 
进程id：进程有唯一的id，用pid_t类型表示，其实就是一个非负整数
进程的状态：创建、就绪、运行、阻塞（挂起）、结束（停止）
进程切换时需要保存和恢复一些CPU寄存器
描述虚拟地址空间信息
描述控制终端的信息
当前工作目录（Current Working Directory）
umask掩码
文件描述符表，包含很多指向file结构体的指针
和信号相关的信息
用户id和组id
会话和进程组
进程可以使用的资源上限

### 进程间的状态转换

创建，就绪，运行，阻塞，终止
就绪太：进行已分配到除了cpu之外的所有必要资源后，只要再获得cpu，可以立即执行
阻塞太：指进程不具备运行条件，正在等待某个事件完成

ps aux/ajx 快照，非动态显示
a:显示终端上所有的进程，包括其他用户的进程
u:显示进程详细信息
x:显示没有控制终端的进程
j:列出与作业控制相关的信息

PID 进程ID
PPID 父进程ID
PGID 进程组ID
SID 会话ID

TTY 所属于的终端
STAT：
D 不可中断 R正在运行或在队列中的进程
S大写 处于休眠 T停止
Z 僵尸进程 W 进入内存交换
X 死掉的进程    <高优先级
N 低优先级 s包含子进程
+ 位于前台的进程组

top
-d 指定更新的事件
M 按内存使用量
P 按CPU使用率
T 根据进程运行时间长短
U 根据用户名
K 输入指定的PID杀死进程

kill -l 列出所有信号
killall name 根据进程名杀死

### 进程号和相关函数
进程号唯一但可以重用，进程号类型为pid_t 进程号范围0~32767
除init进程其他进程都是由另一个进程创建，PPID
终端是执行进程的父进程
进程组是一个或多个进程的几何。他们之间相互关联，进程组可以接受同一终端的各种信号，关联的进程有一个进程组号(PGID)。默认情况下，当前的进程号会当作当前的进程组号。

相关函数
pid_t gepid(void);
pid_t geppid(void);
pid_t gepgid(pid_t pid);

### 进程创建

fork() exev函数族

### 父子进程虚拟地址空间情况
执行到 pid_t pid = fork(); 时
复制一份虚拟地址空间 只有pid和栈中fork()返回值pid不同
写时拷贝 读时共享
不复制整个进程的地址空间，让父子共享一个，(父子有两处不同↑)
资源的复制是在需要写入时才会进行

### GDB多进程调试
调试父进程或者子进程：set follow-fork-mode [parent(默认) | child]

设置调试模式：set detach-on-fork [on | off]
设置off 当调试当前进程时，其他进程会被GDB挂起

查看调试的进程： info inferiors
更改进程：inferior n
使进程脱离GDB调试：detach inferiors id

### exec 函数族
一系列功能相同或相似的函数
作用：根据指定文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。

exec函数族的函数执行成功后不会返回，因为已经被替换
l(list)         参数地址列表，以空指针结尾
v(vector)       存有各参数地址的指针数组地址
p(path)         按PATH环境变量指定的目录搜索可执行文件
e(environment)  存有环境变量字符串地址的指针数组地址


### 进程控制 孤儿进程 僵尸进程


### 进程退出

#include <stdlib.h>
void exit(int status); //标准C库 调用退出处理函数 刷新I/O

#include <unistd.h>
void _exit(int status);

### 孤儿进程
父进程结束结束，但子进程还在运行(未运行结束)
每当出现一个孤儿进程的时候，内核就把孤儿进程设置父进程为init()
而init()进程会循环地wait()它已经退出的子进程。这样， 当一个孤儿进程结束了生命周期，init进程处理它的一切善后哦工作。
孤儿进程没有什么危害

### 僵尸进程
每个进程结束之后，都会释放自己地址空间中用户区数据，内核区的PCB没有办法释放掉，需要父进程去释放。
进程终止时，父进程尚未回收，子进程残留资源(PCB)存放于内核中，变成僵尸进程。
不能被kill -9 杀死
如果父进程不用wait() waitpid() 保留的信息不会释放，其进程号被一直占用，但系统所能使用的进程号有限。大量僵尸进程有危害。

进程退出时，内核释放该进程所有的资源，包括打开的文件、占用的内存等。但是为其保留一定的信息，这些信息主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。

wait waitpid 阻塞
waitpid可以设置不阻塞 还可以指定哪个子进程结束
一次wait或waitpid调用只能清理一个子进程，清理多个使用循环

### 退出信息相关宏函数





### 查看闪退日志
cd /var/log/

cat apport.log

VNC mobaxterm


















# Linux多进程开发