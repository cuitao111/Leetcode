## 线程
线程是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一程序中的所有线程均会独立执行相同程序，且共享一份全局内存区域，包括初始化数据段、未初始化数据段，以及堆内存段。

进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。

线程是轻量级的进程，在Linux环境下线程的本质仍是进程。

查看指定的进程LWP号: ps -Lf pid 

### 线程和进程 =的区别
进程间的信息难以共享，
调用fork来创建进程的代价相对较高， 即便利用写时复制计数，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着fork()调用的时间上的开销依然不菲。
线程间能够方便快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。
创建线程比进程通常要块10倍甚至更多。线程间是共享虚拟地址空间的，无需写时复制，也无需复制页表。

### 线程资源
共享资源（内核）：
进程ID和父进程ID
进程组ID和会话ID
用户ID和用户组ID
文件描述符表
信号处理
文件系统相关：文件权限掩码(umask)、当前工作目录
虚拟地址空间（除栈、.text)

非共享：
线程ID、信号掩码（阻塞信号集）、线程特有数据，error变量
实时调度策略和优先级、栈，本地变量和函数调用链接信息

### NPTL
NGPT NPTL


## 线程同步
线程优势在于，能够通过全局变量来共享信息。必须确保多个线程不能同时修改一个变量。
临界区  是指访问某一共享资源的**代码片段**，并且这个片段的执行为原子操作，也就是同时访问同一共享资源的其他进程不应中断该片段的执行。
线程同步：当有一个线程对内存操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能访问内存，

## 互斥锁
针对共享资源锁定互斥量
访问共享资源
对互斥量解锁
pthread_mutex_t

## 死锁
当超过一个线程加锁超过同一组互斥量时，就有可能发生死锁。
两个以上进程在争夺共享资源发生互相等待的现象。
场景： 忘记释放锁，重复加锁， 多线程多锁，抢占锁资源
互斥
请求保持
不可剥夺（与互斥类似）
环路等待


## 读写锁
三个线程同时读没问题

特点：
如果有其他线程读数据，则允许其他线程执行读操作，不允许写。（计数）
如果有其他线程写数据，则其他线程都不允许读、写操作。
写是独占的，写的优先级高。

pthread_rwlock_t
int pthread_rwlock_init()

## 生产者消费者模型
生产者 消费者 容器
同步  容器满 容器空

## 条件变量


### 问题


并发并行 同步异步

两个进程中的线程号能重复？

分页

每一个子节用自己的话复述

int pthread_join(pthread_t thread, void **retval);
为什么传递二级指针

## 重点
线程API
创建
连接
分离
终止
互斥
生产者 消费者
条件变量 信号量