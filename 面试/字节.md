## 多线程同步方式
信号量semaphore：是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步。P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。

管道：一个进程通过调用管程的一个过程进入管程。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。

消息队列：消息的链接表，放在内核中。消息队列独立于发送与接收进程，进程终止时，消息队列及其内容并不会被删除；消息队列可以实现消息的随机查询，可以按照消息的类型读取。

## 进程
管道， 系统ipc （消息队列， 信号，信号量，共享内存），

## 2.53 简述epoll和select的区别，epoll为什么高效？
（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。

（2）每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。

（3）select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。

epoll为什么高效：

（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。

（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

## 2.54 说说多路IO复用技术有哪些，区别是什么？
参考回答

select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。

区别：

（1）poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。

（2）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。

（3）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。

## 2.55 简述socket中select，epoll的使用场景和区别，epoll水平触发与边缘触发的区别？
参考回答

select，epoll的使用场景：都是IO多路复用的机制，应用于高并发的网络编程的场景。I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。

select，epoll的区别：

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。

（2）每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。

（3）select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。

epoll水平触发与边缘触发的区别

LT模式（水平触发）下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作；

而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。

## new malloc区别
操作符 函数
指定大小 返回指针需要强转
报错 抛出异常 null
重载
安全性
构造和析构函数
底层： malloc brk() mmap() 内存池 通过链表将内存空闲块连接，
new:内存被分配（通过operator new函数）
为被分配的内存调用一个或多个构造函数



## delete 和 delete[]
 C++告诉我们在回收用 new 分配的单个对象的内存空间的时候用 delete，回收用 new[] 分配的一组对象的内存空间的时候用 delete[]。

## struct 和 class 的区别
静态成员 函数
默认public 不可修改
继承
直接初始化成员

## 指针与引用
定义：实体 和别名
引用定义之后不可变
不能为空
sizeof

## 红黑树
根节点为黑色，叶子节点为黑色
红色节点的子节点为黑色
从每个节点到其叶子节点经过的黑色节点数量相同
非严格平衡的二叉搜索树

## B+树
m阶B+树
根至少有两个节点
每个节点至多m个关键字，m棵子树
除根节点，非叶子节点至少有m/2子树
叶子节点存放数据，叶子节点内关键字有序，叶子节点之间也是有序的
非叶子节点可看成索引，是其子节点中关键字最小（最大的值）




## 拥塞
拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。
流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。


## define和const
生效于预编译 编译
检查错误
是否放在内存中

### LRU
双向链表+ hashmap
map用来看是否存在key

## 智能指针
智能指针 shared_ptr和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。

## 四类转换
const_cast ：将常量指针或引用转换为非常量指针
static_cast ：
dynamic_cast ： 
reinterpret_cast：

## string和vector
扩容 2倍扩容
string 与 vector<char>

## 堆

## 大数据查询

## 设计模式

## 总结
C++
数据结构与算法
项目

为什么new安全

shared_ptr

构造函数和析构函数做了什么


