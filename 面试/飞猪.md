# 面试时间 3.28

## 面经汇总
### 1.如何实现多态？
就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。

实现原理
当类中存在虚函数时，编译器会在类中自动生成一个虚函数表
虚函数表是一个存储类成员函数指针的数据结构
虚函数表由编译器自动生成和维护
virtual 修饰的成员函数会被编译器放入虚函数表中
存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）

当父类中存在一个虚函数时，编译器会给父类分配一个vptr指针，指向类中的虚函数表，表里存放虚函数的函数指针。
当编译器编译子类时，由于重写的函数是重写了父类的，写不写都会为其自动添加一个vritual，然后编译器给子类对象自动添加了一个vptr指针，指向子类的虚函数表，存放子类的虚函数的函数指针
当代码中存在子类调用虚函数的语句时，编译器不会静态地将父类的函数编译过来，而是运行时动态的根据base指向的对象，找到对象的vptr指针，找到对象的虚函数表，最后调用相应的函数，实现多态。

父类的构造方法中调用虚函数，不会发生多态。这个和 vptr 的分步初始化有关。

子类的构造时会先调用父类的构造函数，这时候vptr会先指向父类的虚函数表
子类构造完毕之后，vptr指向才确定

类的多态性和函数的多态性

重写和重载


### 2.继承关系的类，构造函数和析构函数的调用顺序
先调用派生类中的构造函数，在进入函数体之前调用基类构造函数，执行完毕后，再继续执行派生类中的构造函数，执行完毕对象创建成功
基类构造函数的调用是在派生类构造函数初始化列表之后调用
基类的析构函数晚于派生类释放

### 程序如何判断一个函数是虚函数？
两个成员函数分别定义在基类和派生类中
基类中成员必须带有vritual，派生类成员函数可带可不带
两个成员函数原型必须相同


### 程序启动的过程：

操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。

加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。

加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数

初始化应用程序的全局变量，对于全局对象自动调用构造函数。

进入应用程序入口点函数开始执行。




## tips（自己想到的）:
解释型语言，是在运行的时候将程序翻译成机器语言。 解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。 这样解释型语言每执行一次就要翻译一次，效率比较低。

### malloc和new的区别：
1. 属性
    new/delete是C++关键字，需要编译器的支持。malloc/free是库函数，需要头文件支持。
2. 参数
   使用new操作符申请内存分配时无须指定内存块大小，编译器会根据类型信息自行计算。 malloc需要指定分配大小
3. 返回类型
    new操作符内存分配成功时，返回对象类型指针，类型严格与对象匹配，无需类型转换，new是符合类型安全性的操作符。而malloc内存分配成功则返回void *，需要通过强制类型转换成需要的类型。
4. 分配失败
   new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NLL
5. 自定义类型
   new会先调用operator new函数，申请足够内存（通常底层使用malloc实现） 然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常调用底层free实现）
    malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
6. 重载
   C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上位对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
7. 内存区域
   new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用maclloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于队中。

### static关键字的作用
1. 定义全局静态变量和局部静态变量
全局静态变量的作用域：源文件开始到结束
局部静态变量作用域：函数内部
2. 定义静态函数，只能在本源文件中使用
3. 可以用于定义类中的静态成员函数变量，既可以当成全局变量去存储，又被隐藏在类内部。类中static静态数据成员拥有一块单独的存储区，不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块存储空间。
4. 可以用于定义类中的静态成员函数。与静态成员变量相似，类里面同样可以定义静态成员函数。只需要在函数前加static即可。静态成员函数也是类的一部分，而不是对象的一部分。所有这些对象的静态数据都共享这一块静态存储空间。
当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋值给成员函数的this指针。而静态成员函数不属于任意一个对象，因此静态成员函数没有this指针。既然没有指向某一对象也就无法通过一个对象堆非静态成员访问。

### 堆和栈
区别，优缺点
空间分配方式：系统自动分配释放，存放函数参数值，局部变量， 程序员
缓存方式不同：栈是一级缓存，被调用时处于存储空间，调用完毕立即释放，栈是二级缓存速度慢
结构：先进先出

### 浅拷贝和深拷贝
1.浅：本质上来说源对象和目标对象共用一份实体，
2.深拷贝：开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，不会出现释放同意块内存的错误

### 进程间的通信
管道、系统IPC（包括消息队列、信号量、信号、共享内存）、套接字socket

### 线程通信
临界区、互斥量、信号量、条件变量、读写锁：

### nullptr 和null
 nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。

### 内联函数
宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
一般不和vritual一起使用
函数的inline属性是在编译时确定的，然而，virtual的性质是在运行时确定的，这两个不能同时存在，只能有一个选择，文件中的inline关键字只是对编译器的建议，编译器是否采纳是编译器的事情。 内联函数是个静态行为，而虚函数是个动态行为，他们之间是有矛盾的。

### new和malloc区别
new是操作符，而malloc是函数。
new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。
malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
new可以被重载；malloc不行
new分配内存更直接和安全。
new发生错误抛出异常，malloc返回null

### C++类型转换
const_cast , static_cast , dynamic_cast , reinterpret_cast


### C++操作符优先级
指针最优，单目运算优于双目运算符
先算数运算，后移位运算，最后位运算
*p++ 先取指针p指向的值，在将指针自增1 相当于 *(p++)
（* 和++两个处于同一优先级，结合方向自右向左）
(*p)++先去p指向的值，再自增1
*++p先将指针p自增1，操作再取出该值
++*p先取指针p指向的值（数组第一个元素1），再将值自增1



### 继承的三种方式
1.公有继承
基类的公有成员和保护成员作为派生类成员时，他们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生子类访问
2.私有继承
私有继承的特点是基类的共有和保护成员都派生为私有，并不能被子类访问
3.保护继承
基类所有的公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或者友元访问，基类的私有成员仍然是私有的。
4.所有private都不能被子类访问，protect成员只能被派生类成员函数和友元访问
class默认private继承 struct默认public，一般都是public继承

### c与c++ struct
c中限制较多， 不能右静态成员 函数，默认public不能修改，不可以继承，不可以直接初始化数据成员，使用时不能省略

### 友元
使用friend定义 不是类的成员在类内有声明，有权访问类的所有私有成员和保护成员

### STL容器
**顺序容器**
vector-数组，元素不够时再重新分配，拷贝原来数组的元素到新分配的数组中。
二倍增长速度动态增长，push_back发现内存不足，重新分配一段长度为2的空间，再复制，当元素为非内部元素时性能消耗较大。
clear操作只是把vector.size()清零，但元素还在内存里，导致内存泄露
vector<int> ().swap(V)


list-单链表。
双向链表 内存空间可以不连续，通过指针进行数据访问，随机存储 查找很低效，因此list没有提供[] ,但是list可以很好地支持任意地方插入和删除，只需要移动相应的指针即可。

deque-分配中央控制器map ，map记录着一系列的固定长度的数组的地址。这个map仅仅保存的时数组的地址，真正的数据放在数组中存放。deque先从map中央的位置（双向队列）找到一个数组地址，向数组中存放数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map，把原来map中的内容copy到新的map中。所以使用deque的复杂度要大于vector，尽量使用vector。

stack-基于deque
queue-基于deque
heap-完全二叉树，使用最大堆排序，以数组（vector的形式存放）
priority_queue基于heap
slist-双向链表

**关联式容器** 
set map multiset multimap -基于红黑树，一种加上了额外平衡条件的二叉搜索树

hash table 散列表。将代存数据的key经过映射函数变成一个数组的索引
然后将数据作为此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值（碰撞问题，可以用线性探测二次线性探测来解决）STL是用开链来解决，每一个数组的元素维护一个list，把相同的索引的数据存入list，这样当list比较短的执行删除，插入，搜索等算法比较块。

**容器适配器**
queue、stack、priority_queue

hash_map, hash_set, hash_multiset, hash_multimap-基于hash table
顺序性容器（vector、deque、list）、关联容器（map、set）、容器适配器（queue、stack）

### STL 中 map hashtable deque list 的实现原理
1.map:
内部实现了一个[红黑树](./算法/%E7%BA%A2%E9%BB%91%E6%A0%91.md)（非严格平衡的二叉树，AVL是严格平衡的），有自动排序功能,因此map内部的所有元素都是有序的，红黑树的每一个节点都是map的一个元素。对map的增删查都是相当于对红黑树操作。map中的元素是按照
2. hash table 函数映射
3. deque 双向队列
4. list双向链表

### STL容器的查找时间
插入  查看  删除
1.vector 
N     1     N
2.deque
N     1     N
3.list
1     N     1
4.map set (平衡二叉树)
logN  logN  logN
5.unordered_map,unordered_set
最好1 最坏N


### 进程调度的算法
先来先服务调度算法

短作业(进程)优先调度算法

高优先级优先调度算法

时间片轮转法

多级反馈队列调度算法


### map与unordered_map区别
红黑树 和 哈希表

### TCP UDP区别
1.TCP有连接的通信 三次握手
2.TCP传输是可靠的，超时重传，UDP是保证最大交付
3.所需资源开销不同TCP是20 UDP8
4.TCP右拥塞控制和流量控制
5.一对一
6.面向字节流，面向报文


### 虚析构和虚构造
我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
如果基类的析构函数不是虚函数，在特定情况下会导致派生来无法被析构。

虚构造
从存储空间角度：虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数，就需要到vtable 中调用，可是对象还没有实例化，无法调用。

从使用角度：构造函数本身就是要初始化实例，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数   ，
构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

### 进程和线程
包含
一个线程挂了
资源调度 CPU调度
资源开销
独立的内存单元 

### 哈希表解决冲突的方法
1、开放定址 
2、链地址
3、公共溢出区
4、再hash

### extern作用
extern是c++引入的一个关键字，它可以应用于一个全局变量，函数或模板声明，说明该符号具有外部链接(external linkage)属性。 也就是说，这个符号在别处定义。 一般而言，C++全局变量的作用范围仅限于当前的文件，但同时C++也支持分离式编译，允许将程序分割为若干个文件被独立编译。

### time_wait持续了多久
time_wait 状态，默认会持续2 MSL(报文的最大生存时间)，一般是2x2 mins.

## 项目介绍

### 自我介绍
我是来自北京交通大学的23届毕业生崔涛，本科就读于中国石油大学（华东），专业是计算机科学与技术
本科期间参加过多次团队合作的比赛以及项目，如数学建模的国赛，程序设计大赛，以及大学生创新项目，另外，在本科课程设计时了解过web开发框架，如Spring MVC Django等，之后保送进入北京交通大学，目前的研究方向为深度学习，计算机视觉，视频异常行为检测，研究生期间，参与开发过老师的项目，如铁路人员通行手势检测，地铁场景人体骨架提取，并将自己的科研成果写成论文发表在IGTA2021会议。

## 论文
基础 resnet Yolo

草稿纸 


## 面试总结

目前服务的后端都是用java或者go语言，有了解过吗

问了两个项目

专业课程中有数字图像处理，说一下数据增强的一些方法

TCP/IP 拥塞机制 

C++11新特性 智能指针

非对称加密和对称加密
